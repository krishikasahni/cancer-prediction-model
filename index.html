<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cancer Prediction System - AI/ML Platform</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef } = React;
        
        const Icon = ({ d, ...props }) => (
            React.createElement('svg', { ...props, xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                d.map((path, i) => React.createElement('path', { key: i, d: path }))
            )
        );

        const CancerPredictionSystem = () => {
          const [data, setData] = useState(null);
          const [models, setModels] = useState({});
          const [results, setResults] = useState(null);
          const [training, setTraining] = useState(false);
          const [progress, setProgress] = useState('');
          const [prediction, setPrediction] = useState(null);
          const [inputValues, setInputValues] = useState({});
          const fileInputRef = useRef(null);

          const parseCSV = (text) => {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            const rows = lines.slice(1).map(line => {
              const values = line.split(',').map(v => v.trim());
              return headers.reduce((obj, header, i) => {
                obj[header] = values[i];
                return obj;
              }, {});
            });
            return { headers, rows };
          };

          const normalizeData = (data) => {
            const values = data.map(row => parseFloat(row));
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min;
            if (range === 0) return values.map(() => 0.5);
            return values.map(v => (v - min) / range);
          };

          const handleFileUpload = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const text = await file.text();
            const parsed = parseCSV(text);
            const targetCol = parsed.headers[parsed.headers.length - 1];
            const featureCols = parsed.headers.slice(0, -1);
            
            // Convert M/B to 1/0
            const processedRows = parsed.rows.map(row => {
              const newRow = { ...row };
              const diagValue = row[targetCol];
              if (diagValue === 'M' || diagValue === 'm' || diagValue === '1') {
                newRow[targetCol] = '1';
              } else if (diagValue === 'B' || diagValue === 'b' || diagValue === '0') {
                newRow[targetCol] = '0';
              }
              return newRow;
            });
            
            setData({
              headers: parsed.headers,
              rows: processedRows,
              featureCols,
              targetCol,
              numSamples: processedRows.length,
              numFeatures: featureCols.length
            });
            setProgress('Data loaded successfully! (M→1, B→0 converted)');
          };

          const trainModels = async () => {
            if (!data) return;
            setTraining(true);
            setProgress('Preparing data...');
            
            const features = data.rows.map(row => 
              data.featureCols.map(col => parseFloat(row[col]) || 0)
            );
            const labels = data.rows.map(row => parseFloat(row[data.targetCol]) || 0);
            
            const normalizedFeatures = [];
            for (let i = 0; i < data.numFeatures; i++) {
              const column = features.map(row => row[i]);
              const normalized = normalizeData(column);
              normalizedFeatures.push(normalized);
            }
            
            const X = features.map((_, i) => normalizedFeatures.map(col => col[i]));
            const splitIdx = Math.floor(X.length * 0.8);
            const XTrain = X.slice(0, splitIdx);
            const yTrain = labels.slice(0, splitIdx);
            const XTest = X.slice(splitIdx);
            const yTest = labels.slice(splitIdx);
            
            setProgress('Training Deep Neural Network...');
            const dlModel = await trainDeepLearningModel(XTrain, yTrain);
            
            setProgress('Training Logistic Regression...');
            const lrModel = trainLogisticRegression(XTrain, yTrain);
            
            setProgress('Training Random Forest...');
            const rfModel = trainRandomForest(XTrain, yTrain);
            
            setProgress('Evaluating models...');
            const dlPreds = await predictDL(dlModel.model, XTest);
            const lrPreds = predictLR(lrModel, XTest);
            const rfPreds = predictRF(rfModel, XTest);
            
            const dlMetrics = calculateMetrics(yTest, dlPreds);
            const lrMetrics = calculateMetrics(yTest, lrPreds);
            const rfMetrics = calculateMetrics(yTest, rfPreds);
            
            setModels({ dl: dlModel.model, lr: lrModel, rf: rfModel });
            setResults({
              deepLearning: dlMetrics,
              logisticRegression: lrMetrics,
              randomForest: rfMetrics
            });
            setTraining(false);
            setProgress('Training complete!');
          };

          const trainDeepLearningModel = async (XTrain, yTrain) => {
            const model = tf.sequential({
              layers: [
                tf.layers.dense({ inputShape: [XTrain[0].length], units: 64, activation: 'relu' }),
                tf.layers.dropout({ rate: 0.3 }),
                tf.layers.dense({ units: 32, activation: 'relu' }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.dense({ units: 16, activation: 'relu' }),
                tf.layers.dense({ units: 1, activation: 'sigmoid' })
              ]
            });
            
            model.compile({
              optimizer: tf.train.adam(0.001),
              loss: 'binaryCrossentropy',
              metrics: ['accuracy']
            });
            
            const xs = tf.tensor2d(XTrain);
            const ys = tf.tensor2d(yTrain, [yTrain.length, 1]);
            
            await model.fit(xs, ys, {
              epochs: 50,
              batchSize: 32,
              validationSplit: 0.2
            });
            
            xs.dispose();
            ys.dispose();
            return { model };
          };

          const trainLogisticRegression = (XTrain, yTrain) => {
            const weights = new Array(XTrain[0].length).fill(0);
            let bias = 0;
            const lr = 0.01;
            const epochs = 1000;
            
            for (let e = 0; e < epochs; e++) {
              for (let i = 0; i < XTrain.length; i++) {
                const x = XTrain[i];
                const y = yTrain[i];
                let z = bias;
                for (let j = 0; j < x.length; j++) z += weights[j] * x[j];
                const pred = 1 / (1 + Math.exp(-z));
                const error = pred - y;
                bias -= lr * error;
                for (let j = 0; j < weights.length; j++) weights[j] -= lr * error * x[j];
              }
            }
            return { weights, bias };
          };

          const trainRandomForest = (XTrain, yTrain) => {
            const numTrees = 10;
            const trees = [];
            for (let t = 0; t < numTrees; t++) {
              const sampleSize = Math.floor(XTrain.length * 0.8);
              const indices = [];
              for (let i = 0; i < sampleSize; i++) {
                indices.push(Math.floor(Math.random() * XTrain.length));
              }
              const XSample = indices.map(i => XTrain[i]);
              const ySample = indices.map(i => yTrain[i]);
              trees.push(trainLogisticRegression(XSample, ySample));
            }
            return { trees };
          };

          const predictDL = async (model, X) => {
            const tensor = tf.tensor2d(X);
            const preds = model.predict(tensor);
            const values = await preds.data();
            tensor.dispose();
            preds.dispose();
            return Array.from(values).map(v => v > 0.5 ? 1 : 0);
          };

          const predictLR = (model, X) => {
            return X.map(x => {
              let z = model.bias;
              for (let j = 0; j < x.length; j++) z += model.weights[j] * x[j];
              return (1 / (1 + Math.exp(-z))) > 0.5 ? 1 : 0;
            });
          };

          const predictRF = (model, X) => {
            return X.map(x => {
              const votes = model.trees.map(tree => {
                let z = tree.bias;
                for (let j = 0; j < x.length; j++) z += tree.weights[j] * x[j];
                return (1 / (1 + Math.exp(-z))) > 0.5 ? 1 : 0;
              });
              return votes.reduce((a, b) => a + b, 0) > votes.length / 2 ? 1 : 0;
            });
          };

          const calculateMetrics = (yTrue, yPred) => {
            let tp = 0, tn = 0, fp = 0, fn = 0;
            for (let i = 0; i < yTrue.length; i++) {
              if (yTrue[i] === 1 && yPred[i] === 1) tp++;
              else if (yTrue[i] === 0 && yPred[i] === 0) tn++;
              else if (yTrue[i] === 0 && yPred[i] === 1) fp++;
              else if (yTrue[i] === 1 && yPred[i] === 0) fn++;
            }
            const accuracy = (tp + tn) / (tp + tn + fp + fn);
            const precision = tp / (tp + fp) || 0;
            const recall = tp / (tp + fn) || 0;
            const f1 = 2 * (precision * recall) / (precision + recall) || 0;
            const specificity = tn / (tn + fp) || 0;
            return { accuracy, precision, recall, f1, specificity, tp, tn, fp, fn };
          };

          const makePrediction = async () => {
            if (!models.dl || !data) return;
            const features = data.featureCols.map(col => parseFloat(inputValues[col]) || 0);
            const normalizedFeatures = [];
            for (let i = 0; i < data.numFeatures; i++) {
              const column = data.rows.map(row => parseFloat(row[data.featureCols[i]]) || 0);
              const min = Math.min(...column);
              const max = Math.max(...column);
              const range = max - min;
              if (range === 0) {
                normalizedFeatures.push(0.5);
              } else {
                normalizedFeatures.push((features[i] - min) / range);
              }
            }
            
            const dlPred = await predictDL(models.dl, [normalizedFeatures]);
            const lrPred = predictLR(models.lr, [normalizedFeatures]);
            const rfPred = predictRF(models.rf, [normalizedFeatures]);
            
            const tensor = tf.tensor2d([normalizedFeatures]);
            const dlProb = await models.dl.predict(tensor).data();
            tensor.dispose();
            
            let lrZ = models.lr.bias;
            for (let j = 0; j < normalizedFeatures.length; j++) lrZ += models.lr.weights[j] * normalizedFeatures[j];
            const lrProb = 1 / (1 + Math.exp(-lrZ));
            
            const rfProbs = models.rf.trees.map(tree => {
              let z = tree.bias;
              for (let j = 0; j < normalizedFeatures.length; j++) z += tree.weights[j] * normalizedFeatures[j];
              return 1 / (1 + Math.exp(-z));
            });
            const rfProb = rfProbs.reduce((a, b) => a + b, 0) / rfProbs.length;
            
            setPrediction({
              deepLearning: { result: dlPred[0], probability: Math.max(0.01, Math.min(0.99, dlProb[0])) },
              logisticRegression: { result: lrPred[0], probability: Math.max(0.01, Math.min(0.99, lrProb)) },
              randomForest: { result: rfPred[0], probability: Math.max(0.01, Math.min(0.99, rfProb)) }
            });
          };

          const MetricCard = ({ label, value, color }) => (
            <div className={`p-4 rounded-lg bg-${color}-100 text-${color}-700`}>
              <p className="text-sm font-medium opacity-80">{label}</p>
              <p className="text-2xl font-bold mt-1">{(value * 100).toFixed(2)}%</p>
            </div>
          );

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-4 md:p-8">
              <div className="max-w-6xl mx-auto">
                <div className="bg-white rounded-2xl shadow-xl p-6 md:p-8">
                  <div className="flex items-center gap-3 mb-8">
                    <Icon d={["M22 12h-4l-3 9L9 3l-3 9H2"]} className="w-10 h-10 text-indigo-600" />
                    <h1 className="text-2xl md:text-3xl font-bold text-gray-800">Cancer Prediction System</h1>
                  </div>

                  <div className="mb-8">
                    <div className="border-2 border-dashed border-indigo-300 rounded-lg p-8 text-center">
                      <Icon d={["M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", "M17 8l-5-5-5 5", "M12 3v12"]} className="w-12 h-12 text-indigo-400 mx-auto mb-4" />
                      <p className="text-gray-600 mb-4">Upload your cancer dataset (CSV format)</p>
                      <input ref={fileInputRef} type="file" accept=".csv" onChange={handleFileUpload} className="hidden" />
                      <button onClick={() => fileInputRef.current?.click()} className="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 transition">
                        Select CSV File
                      </button>
                    </div>
                  </div>

                  {data && (
                    <div className="mb-8 p-6 bg-blue-50 rounded-lg">
                      <h3 className="font-semibold text-lg mb-3">Dataset Information</h3>
                      <div className="grid grid-cols-2 gap-4">
                        <div><p className="text-sm text-gray-600">Samples</p><p className="text-2xl font-bold text-indigo-600">{data.numSamples}</p></div>
                        <div><p className="text-sm text-gray-600">Features</p><p className="text-2xl font-bold text-indigo-600">{data.numFeatures}</p></div>
                      </div>
                    </div>
                  )}

                  {data && (
                    <div className="mb-8">
                      <button onClick={trainModels} disabled={training} className="w-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white px-8 py-4 rounded-lg hover:from-indigo-700 hover:to-purple-700 transition disabled:opacity-50 flex items-center justify-center gap-2 text-lg font-semibold">
                        <Icon d={["M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z", "M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"]} className="w-6 h-6" />
                        {training ? 'Training Models...' : 'Train All Models'}
                      </button>
                      {progress && <p className="text-center mt-4 text-indigo-600 font-medium">{progress}</p>}
                    </div>
                  )}

                  {results && (
                    <div className="space-y-6">
                      <h2 className="text-2xl font-bold text-gray-800 flex items-center gap-2">
                        <Icon d={["M3 3v18h18", "M18 17V9", "M13 17V5", "M8 17v-3"]} className="w-6 h-6 text-indigo-600" />
                        Model Performance
                      </h2>

                      <div className="p-6 bg-gradient-to-r from-purple-50 to-indigo-50 rounded-lg border-2 border-purple-200">
                        <h3 className="text-xl font-bold text-purple-700 mb-4">Deep Neural Network</h3>
                        <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                          <MetricCard label="Accuracy" value={results.deepLearning.accuracy} color="purple" />
                          <MetricCard label="Precision" value={results.deepLearning.precision} color="purple" />
                          <MetricCard label="Recall" value={results.deepLearning.recall} color="purple" />
                        </div>
                      </div>

                      <div className="p-6 bg-gradient-to-r from-blue-50 to-cyan-50 rounded-lg border-2 border-blue-200">
                        <h3 className="text-xl font-bold text-blue-700 mb-4">Logistic Regression</h3>
                        <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                          <MetricCard label="Accuracy" value={results.logisticRegression.accuracy} color="blue" />
                          <MetricCard label="Precision" value={results.logisticRegression.precision} color="blue" />
                          <MetricCard label="Recall" value={results.logisticRegression.recall} color="blue" />
                        </div>
                      </div>

                      <div className="p-6 bg-gradient-to-r from-green-50 to-emerald-50 rounded-lg border-2 border-green-200">
                        <h3 className="text-xl font-bold text-green-700 mb-4">Random Forest</h3>
                        <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                          <MetricCard label="Accuracy" value={results.randomForest.accuracy} color="green" />
                          <MetricCard label="Precision" value={results.randomForest.precision} color="green" />
                          <MetricCard label="Recall" value={results.randomForest.recall} color="green" />
                        </div>
                      </div>

                      <div className="mt-8 p-6 bg-gradient-to-r from-teal-50 to-cyan-50 rounded-lg border-2 border-teal-200">
                        <h2 className="text-2xl font-bold text-teal-700 mb-4">Make a Prediction</h2>
                        <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mb-6">
                          {data.featureCols.map(col => (
                            <div key={col}>
                              <label className="block text-sm font-medium text-gray-700 mb-2">{col}</label>
                              <input type="number" step="any" value={inputValues[col] || ''} onChange={(e) => setInputValues(prev => ({ ...prev, [col]: e.target.value }))} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-teal-500" placeholder="Enter value" />
                            </div>
                          ))}
                        </div>
                        <button onClick={makePrediction} className="w-full bg-gradient-to-r from-teal-600 to-cyan-600 text-white px-6 py-4 rounded-lg hover:from-teal-700 hover:to-cyan-700 transition font-semibold">
                          Predict Diagnosis
                        </button>

                        {prediction && (
                          <div className="mt-6 space-y-4">
                            {[
                              { name: 'Deep Learning', data: prediction.deepLearning, color: 'purple' },
                              { name: 'Logistic Regression', data: prediction.logisticRegression, color: 'blue' },
                              { name: 'Random Forest', data: prediction.randomForest, color: 'green' }
                            ].map(({ name, data, color }) => (
                              <div key={name} className={`p-4 bg-${color}-50 rounded-lg`}>
                                <div className="flex justify-between items-center mb-2">
                                  <span className={`font-semibold text-${color}-700`}>{name}</span>
                                  <span className={`px-4 py-2 rounded-full font-bold ${data.result === 1 ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}`}>
                                    {data.result === 1 ? 'MALIGNANT' : 'BENIGN'}
                                  </span>
                                </div>
                                <div className="w-full bg-gray-200 rounded-full h-3">
                                  <div className={`bg-${color}-600 h-3 rounded-full`} style={{ width: `${data.probability * 100}%` }} />
                                </div>
                                <p className="text-sm text-right mt-1">{(data.probability * 100).toFixed(2)}% confidence</p>
                              </div>
                            ))}
                            <div className="p-4 bg-yellow-50 rounded-lg border-2 border-yellow-300">
                              <p className="text-sm text-gray-600 italic">⚕️ For educational purposes only. Consult healthcare professionals for medical diagnosis.</p>
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CancerPredictionSystem />);
    </script>
</body>
</html>
